{"ast":null,"code":"import { ComponentPortal, PortalModule } from '@angular/cdk/portal';\nimport * as i1$1 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Output, Input, Component, HostListener, ViewEncapsulation, Injectable, InjectionToken, ChangeDetectionStrategy, ViewChild, Optional, Inject, forwardRef, NgModule } from '@angular/core';\nimport * as i4 from '@angular/forms';\nimport { FormGroup, FormControl, Validators, NG_VALUE_ACCESSOR, NG_VALIDATORS, FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport * as i3 from '@angular/material/legacy-button';\nimport { MatLegacyButtonModule } from '@angular/material/legacy-button';\nimport { MatLegacyCardModule } from '@angular/material/legacy-card';\nimport * as i2$1 from '@angular/material/legacy-dialog';\nimport { MatLegacyDialogModule } from '@angular/material/legacy-dialog';\nimport * as i2$2 from '@angular/material/icon';\nimport { MatIconModule } from '@angular/material/icon';\nimport * as i2 from '@angular/material/legacy-input';\nimport { MAT_LEGACY_INPUT_VALUE_ACCESSOR, MatLegacyInputModule } from '@angular/material/legacy-input';\nimport { MatLegacyRadioModule } from '@angular/material/legacy-radio';\nimport { Subject, merge, Subscription, of } from 'rxjs';\nimport { takeUntil, debounceTime, distinctUntilChanged, take, filter } from 'rxjs/operators';\nimport * as i1 from '@angular/material/legacy-form-field';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE, UP_ARROW, DOWN_ARROW } from '@angular/cdk/keycodes';\nimport * as i3$1 from '@angular/cdk/overlay';\nimport { Overlay, OverlayConfig } from '@angular/cdk/overlay';\nimport { mixinColor } from '@angular/material/core';\nimport { matDatepickerAnimations } from '@angular/material/datepicker';\nimport * as i5 from '@angular/cdk/bidi';\nconst _c0 = function (a0) {\n  return {\n    \"active\": a0\n  };\n};\nfunction NgxMatColorCollectionComponent_button_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 2);\n    i0.ɵɵlistener(\"click\", function NgxMatColorCollectionComponent_button_1_Template_button_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r4);\n      const c_r2 = restoredCtx.$implicit;\n      const ctx_r3 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r3.select(c_r2));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const c_r2 = ctx.$implicit;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"background-color\", c_r2);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(3, _c0, ctx_r0.selectedColor === c_r2));\n  }\n}\nfunction NgxMatColorCollectionComponent_button_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 2);\n    i0.ɵɵlistener(\"click\", function NgxMatColorCollectionComponent_button_3_Template_button_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r7);\n      const c_r5 = restoredCtx.$implicit;\n      const ctx_r6 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r6.select(c_r5));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const c_r5 = ctx.$implicit;\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"background-color\", c_r5);\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(3, _c0, ctx_r1.selectedColor === c_r5));\n  }\n}\nconst _c1 = [\"button\"];\nconst trimLeft = /^\\s+/;\nconst trimRight = /\\s+$/;\nconst tinyCounter = 0;\nconst mathRound = Math.round;\nconst mathMin = Math.min;\nconst mathMax = Math.max;\nconst mathRandom = Math.random;\nconst NUMERIC_REGEX = /[^0-9]/g;\nconst MAX_RGB = 255;\nconst MIN_RGB = 0;\n/** List basic colors */\nconst BASIC_COLORS = [\"#ffffff\", \"#ffff00\", \"#ff00ff\", \"#ff0000\", \"#c0c0c0\", \"#808080\", \"#808000\", \"#800080\", \"#800000\", \"#00ffff\", \"#00ff00\", \"#008080\", \"#008000\", \"#0000ff\", \"#000080\", \"#000000\"];\n/**\r\n * Get color at position\r\n * @param ctx\r\n * @param x\r\n * @param y\r\n */\nfunction getColorAtPosition(ctx, x, y) {\n  const imageData = ctx.getImageData(x, y, 1, 1).data;\n  return {\n    r: imageData[0],\n    g: imageData[1],\n    b: imageData[2]\n  };\n}\n// `rgbaToHex`\n// Converts an RGBA color plus alpha transparency to hex\n// Assumes r, g, b are contained in the set [0, 255] and\n// a in [0, 1]. Returns a 4 or 8 character rgba hex\nfunction rgbaToHex(r, g, b, a, allow4Char) {\n  var hex = [pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16)), pad2(convertDecimalToHex(a))];\n  // Return a 4 character hex if possible\n  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {\n    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);\n  }\n  return hex.join(\"\");\n}\n// Force a hex value to have 2 characters\nfunction pad2(c) {\n  return c.length == 1 ? '0' + c : '' + c;\n}\n// Converts a decimal to a hex value\nfunction convertDecimalToHex(d) {\n  return Math.round(parseFloat(d) * 255).toString(16);\n}\n// Converts a hex value to a decimal\nfunction convertHexToDecimal(h) {\n  return parseIntFromHex(h) / 255;\n}\n// Parse a base-16 hex value into a base-10 integer\nfunction parseIntFromHex(val) {\n  return parseInt(val, 16);\n}\n// `rgbToHex`\n// Converts an RGB color to hex\n// Assumes r, g, and b are contained in the set [0, 255]\n// Returns a 3 or 6 character hex\nfunction rgbToHex(r, g, b, allow3Char) {\n  var hex = [pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16))];\n  // Return a 3 character hex if possible\n  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {\n    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);\n  }\n  return hex.join(\"\");\n}\n// Actual matching.\n// Parentheses and commas are optional, but not required.\n// Whitespace can take the place of commas or opening parent\nconst CSS_INTEGER = \"[-\\\\+]?\\\\d+%?\";\nconst CSS_NUMBER = \"[-\\\\+]?\\\\d*\\\\.\\\\d+%?\";\nconst CSS_UNIT = \"(?:\" + CSS_NUMBER + \")|(?:\" + CSS_INTEGER + \")\";\nconst PERMISSIVE_MATCH3 = \"[\\\\s|\\\\(]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")\\\\s*\\\\)?\";\nconst PERMISSIVE_MATCH4 = \"[\\\\s|\\\\(]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")\\\\s*\\\\)?\";\nconst matchers = {\n  CSS_UNIT: new RegExp(CSS_UNIT),\n  rgb: new RegExp(\"rgb\" + PERMISSIVE_MATCH3),\n  rgba: new RegExp(\"rgba\" + PERMISSIVE_MATCH4),\n  hsl: new RegExp(\"hsl\" + PERMISSIVE_MATCH3),\n  hsla: new RegExp(\"hsla\" + PERMISSIVE_MATCH4),\n  hsv: new RegExp(\"hsv\" + PERMISSIVE_MATCH3),\n  hsva: new RegExp(\"hsva\" + PERMISSIVE_MATCH4),\n  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,\n  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/\n};\n// `stringInputToObject`\n// Permissive string parsing.  Take in a number of formats, and output an object\n// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`\nfunction stringInputToObject(color) {\n  color = color.replace(trimLeft, '').replace(trimRight, '').toLowerCase();\n  // Try to match string input using regular expressions.\n  // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]\n  // Just return an object and let the conversion functions handle that.\n  // This way the result will be the same whether the tinycolor is initialized with string or object.\n  let match;\n  let obj;\n  if (match = matchers.rgb.exec(color)) {\n    return {\n      r: match[1],\n      g: match[2],\n      b: match[3],\n      a: 1\n    };\n  }\n  if (match = matchers.rgba.exec(color)) {\n    return {\n      r: match[1],\n      g: match[2],\n      b: match[3],\n      a: match[4]\n    };\n  }\n  if (match = matchers.hex8.exec(color)) {\n    return {\n      r: parseIntFromHex(match[1]),\n      g: parseIntFromHex(match[2]),\n      b: parseIntFromHex(match[3]),\n      a: convertHexToDecimal(match[4])\n    };\n  }\n  if (match = matchers.hex6.exec(color)) {\n    return {\n      r: parseIntFromHex(match[1]),\n      g: parseIntFromHex(match[2]),\n      b: parseIntFromHex(match[3]),\n      a: 1\n    };\n  }\n  if (match = matchers.hex4.exec(color)) {\n    return {\n      r: parseIntFromHex(match[1] + '' + match[1]),\n      g: parseIntFromHex(match[2] + '' + match[2]),\n      b: parseIntFromHex(match[3] + '' + match[3]),\n      a: convertHexToDecimal(match[4] + '' + match[4])\n    };\n  }\n  if (match = matchers.hex3.exec(color)) {\n    return {\n      r: parseIntFromHex(match[1] + '' + match[1]),\n      g: parseIntFromHex(match[2] + '' + match[2]),\n      b: parseIntFromHex(match[3] + '' + match[3]),\n      a: 1\n    };\n  }\n  return null;\n}\nfunction createMissingDateImplError(provider) {\n  return Error(`NgxMatColorPicker: No provider found for ${provider}. You must define MAT_COLOR_FORMATS in your module`);\n}\nclass Color {\n  constructor(_r, _g, _b, _a) {\n    this.r = _r > MAX_RGB ? MAX_RGB : _r;\n    this.g = _g > MAX_RGB ? MAX_RGB : _g;\n    this.b = _b > MAX_RGB ? MAX_RGB : _b;\n    if (_a != null) {\n      this.a = _a > 1 ? 1 : _a;\n    } else {\n      this.a = 1;\n    }\n    this.roundA = Math.round(this.a);\n    this.hex = rgbToHex(this.r, this.g, this.b);\n    this.rgba = this.toRgba();\n  }\n  toHex(allow3Char) {\n    return rgbToHex(this.r, this.g, this.b, allow3Char);\n  }\n  toRgba() {\n    return `rgba(${this.r},${this.g},${this.b},${this.a})`;\n  }\n  toHexString(allow3Char) {\n    return '#' + this.toHex(allow3Char);\n  }\n  toRgbString() {\n    return this.a === 1 ? \"rgb(\" + Math.round(this.r) + \", \" + Math.round(this.g) + \", \" + Math.round(this.b) + \")\" : \"rgba(\" + Math.round(this.r) + \", \" + Math.round(this.g) + \", \" + Math.round(this.b) + \", \" + this.roundA + \")\";\n  }\n  toHex8(allow4Char) {\n    return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);\n  }\n  toHex8String(allow4Char) {\n    return '#' + this.toHex8(allow4Char);\n  }\n  toString(format) {\n    let formatSet = !!format;\n    let formattedString;\n    let hasAlpha = this.a < 1 && this.a >= 0;\n    let needsAlphaFormat = !formatSet && hasAlpha && (format === \"hex\" || format === \"hex6\" || format === \"hex3\" || format === \"hex4\" || format === \"hex8\");\n    if (needsAlphaFormat) {\n      return this.toRgbString();\n    }\n    if (format === \"rgb\") {\n      formattedString = this.toRgbString();\n    }\n    if (format === \"hex\" || format === \"hex6\") {\n      formattedString = this.toHexString();\n    }\n    if (format === \"hex3\") {\n      formattedString = this.toHexString(true);\n    }\n    if (format === \"hex4\") {\n      formattedString = this.toHex8String(true);\n    }\n    if (format === \"hex8\") {\n      formattedString = this.toHex8String();\n    }\n    return formattedString || this.toHexString();\n  }\n}\nlet NgxMatBaseColorCanvas = /*#__PURE__*/(() => {\n  class NgxMatBaseColorCanvas {\n    constructor(zone, elementId) {\n      this.zone = zone;\n      this.colorChanged = new EventEmitter();\n      this.x = 0;\n      this.y = 0;\n      this.drag = false;\n      this._destroyed = new Subject();\n      this.elementId = elementId;\n    }\n    ngOnDestroy() {\n      this._destroyed.next();\n      this._destroyed.complete();\n    }\n    ngAfterViewInit() {\n      this.canvas = document.getElementById(this.elementId);\n      this.ctx = this.canvas.getContext('2d');\n      this.width = this.canvas.width;\n      this.height = this.canvas.height;\n      this.draw();\n    }\n    draw() {\n      this.ctx.clearRect(0, 0, this.width, this.height);\n      this.ctx.rect(0, 0, this.width, this.height);\n      this.fillGradient();\n      if (this.y != 0) {\n        this.redrawIndicator(this.x, this.y);\n      }\n    }\n    onMousedown(e) {\n      this.drag = true;\n      this.changeColor(e);\n      this.zone.runOutsideAngular(() => {\n        this.canvas.addEventListener('mousemove', this.onMousemove.bind(this));\n      });\n    }\n    onMousemove(e) {\n      if (this.drag) {\n        this.zone.run(() => {\n          this.changeColor(e);\n        });\n      }\n    }\n    onMouseup(e) {\n      this.drag = false;\n      this.canvas.removeEventListener('mousemove', this.onMousemove);\n    }\n    emitChange(color) {\n      this.colorChanged.emit(color);\n    }\n  }\n  /** @nocollapse */NgxMatBaseColorCanvas.ɵfac = function NgxMatBaseColorCanvas_Factory(t) {\n    i0.ɵɵinvalidFactory();\n  };\n  /** @nocollapse */\n  NgxMatBaseColorCanvas.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgxMatBaseColorCanvas,\n    inputs: {\n      color: \"color\"\n    },\n    outputs: {\n      colorChanged: \"colorChanged\"\n    }\n  });\n  return NgxMatBaseColorCanvas;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgxMatColorSliderComponent = /*#__PURE__*/(() => {\n  class NgxMatColorSliderComponent extends NgxMatBaseColorCanvas {\n    constructor(zone) {\n      super(zone, 'color-strip');\n      this.zone = zone;\n    }\n    ngOnInit() {}\n    ngAfterViewInit() {\n      super.ngAfterViewInit();\n    }\n    fillGradient() {\n      const grd = this.ctx.createLinearGradient(0, 0, 0, this.height);\n      grd.addColorStop(0, 'rgba(255, 0, 0, 1)');\n      grd.addColorStop(0.17, 'rgba(255, 255, 0, 1)');\n      grd.addColorStop(0.34, 'rgba(0, 255, 0, 1)');\n      grd.addColorStop(0.51, 'rgba(0, 255, 255, 1)');\n      grd.addColorStop(0.68, 'rgba(0, 0, 255, 1)');\n      grd.addColorStop(0.85, 'rgba(255, 0, 255, 1)');\n      grd.addColorStop(1, 'rgba(255, 0, 0, 1)');\n      this.ctx.fillStyle = grd;\n      this.ctx.fill();\n    }\n    redrawIndicator(x, y) {\n      this.ctx.beginPath();\n      this.ctx.strokeStyle = 'white';\n      this.ctx.lineWidth = 2;\n      this.ctx.arc(7.5, y, 7.5, 0, 2 * Math.PI, false);\n      this.ctx.stroke();\n      this.ctx.closePath();\n    }\n    changeColor(e) {\n      this.x = e.offsetX;\n      this.y = e.offsetY;\n      this.draw();\n      const {\n        r,\n        g,\n        b\n      } = getColorAtPosition(this.ctx, e.offsetX, e.offsetY);\n      this.emitChange(new Color(r, g, b));\n    }\n  }\n  /** @nocollapse */NgxMatColorSliderComponent.ɵfac = function NgxMatColorSliderComponent_Factory(t) {\n    return new (t || NgxMatColorSliderComponent)(i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n  NgxMatColorSliderComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NgxMatColorSliderComponent,\n    selectors: [[\"ngx-mat-color-slider\"]],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 1,\n    vars: 0,\n    consts: [[\"id\", \"color-strip\", \"width\", \"15\", \"height\", \"200\", 1, \"zone-strip\", 3, \"mousedown\", \"mouseup\"]],\n    template: function NgxMatColorSliderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"canvas\", 0);\n        i0.ɵɵlistener(\"mousedown\", function NgxMatColorSliderComponent_Template_canvas_mousedown_0_listener($event) {\n          return ctx.onMousedown($event);\n        })(\"mouseup\", function NgxMatColorSliderComponent_Template_canvas_mouseup_0_listener($event) {\n          return ctx.onMouseup($event);\n        });\n        i0.ɵɵelementEnd();\n      }\n    }\n  });\n  return NgxMatColorSliderComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NumericColorInputDirective = /*#__PURE__*/(() => {\n  class NumericColorInputDirective {\n    constructor() {}\n    onInput($event) {\n      this._formatInput($event.target);\n    }\n    /**\r\n    * Format input\r\n    * @param input\r\n    */\n    _formatInput(input) {\n      let val = Number(input.value.replace(NUMERIC_REGEX, ''));\n      val = isNaN(val) ? 0 : val;\n      input.value = val;\n    }\n  }\n  /** @nocollapse */NumericColorInputDirective.ɵfac = function NumericColorInputDirective_Factory(t) {\n    return new (t || NumericColorInputDirective)();\n  };\n  /** @nocollapse */\n  NumericColorInputDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NumericColorInputDirective,\n    selectors: [[\"\", \"ngxMatNumericColorInput\", \"\"]],\n    hostBindings: function NumericColorInputDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"input\", function NumericColorInputDirective_input_HostBindingHandler($event) {\n          return ctx.onInput($event);\n        });\n      }\n    }\n  });\n  return NumericColorInputDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst RADIUS_NOB = 5;\nlet NgxMatColorCanvasComponent = /*#__PURE__*/(() => {\n  class NgxMatColorCanvasComponent extends NgxMatBaseColorCanvas {\n    constructor(zone) {\n      super(zone, 'color-block');\n      this.zone = zone;\n      this._resetBaseColor = true;\n      this.formGroup = new FormGroup({\n        r: new FormControl(null, [Validators.required]),\n        g: new FormControl(null, [Validators.required]),\n        b: new FormControl(null, [Validators.required]),\n        a: new FormControl(null, [Validators.required]),\n        hex: new FormControl(null, [Validators.required, Validators.pattern(matchers.hex6)])\n      });\n    }\n    get rCtrl() {\n      return this.formGroup.get('r');\n    }\n    get gCtrl() {\n      return this.formGroup.get('g');\n    }\n    get bCtrl() {\n      return this.formGroup.get('b');\n    }\n    get aCtrl() {\n      return this.formGroup.get('a');\n    }\n    get hexCtrl() {\n      return this.formGroup.get('hex');\n    }\n    ngOnInit() {\n      const rgbaCtrl$ = merge(this.rCtrl.valueChanges, this.gCtrl.valueChanges, this.bCtrl.valueChanges, this.aCtrl.valueChanges);\n      rgbaCtrl$.pipe(takeUntil(this._destroyed), debounceTime(400)).subscribe(_ => {\n        const color = new Color(Number(this.rCtrl.value), Number(this.gCtrl.value), Number(this.bCtrl.value), Number(this.aCtrl.value));\n        this.emitChange(color);\n      });\n      const hexCtrl$ = this.hexCtrl.valueChanges;\n      hexCtrl$.pipe(takeUntil(this._destroyed), debounceTime(400), distinctUntilChanged()).subscribe(hex => {\n        const obj = stringInputToObject(hex);\n        if (obj != null) {\n          const color = new Color(obj.r, obj.g, obj.b, obj.a);\n          this.emitChange(color);\n        }\n      });\n    }\n    ngOnChanges(changes) {\n      if (changes.color && changes.color.currentValue) {\n        this.updateForm(changes.color.currentValue);\n        if (this._resetBaseColor) {\n          this._baseColor = changes.color.currentValue;\n        }\n        this._resetBaseColor = true;\n        if (!changes.color.firstChange) {\n          this.draw();\n        }\n      }\n    }\n    updateForm(val) {\n      const config = {\n        emitEvent: false\n      };\n      this.rCtrl.setValue(val.r, config);\n      this.gCtrl.setValue(val.g, config);\n      this.bCtrl.setValue(val.b, config);\n      this.aCtrl.setValue(val.a, config);\n      this.hexCtrl.setValue(val.hex, config);\n    }\n    redrawIndicator(x, y) {\n      this.ctx.beginPath();\n      this.ctx.strokeStyle = 'white';\n      this.ctx.arc(x, y, RADIUS_NOB, 0, 2 * Math.PI, false);\n      this.ctx.stroke();\n      this.ctx.closePath();\n    }\n    fillGradient() {\n      this.ctx.fillStyle = this._baseColor ? this._baseColor.rgba : 'rgba(255,255,255,1)';\n      this.ctx.fillRect(0, 0, this.width, this.height);\n      const grdWhite = this.ctx.createLinearGradient(0, 0, this.width, 0);\n      grdWhite.addColorStop(0, 'rgba(255,255,255,1)');\n      grdWhite.addColorStop(1, 'rgba(255,255,255,0)');\n      this.ctx.fillStyle = grdWhite;\n      this.ctx.fillRect(0, 0, this.width, this.height);\n      const grdBlack = this.ctx.createLinearGradient(0, 0, 0, this.height);\n      grdBlack.addColorStop(0, 'rgba(0,0,0,0)');\n      grdBlack.addColorStop(1, 'rgba(0,0,0,1)');\n      this.ctx.fillStyle = grdBlack;\n      this.ctx.fillRect(0, 0, this.width, this.height);\n    }\n    onSliderColorChanged(c) {\n      this._baseColor = c;\n      this.color = c;\n      this.fillGradient();\n      this.emitChange(c);\n    }\n    changeColor(e) {\n      this.x = e.offsetX;\n      this.y = e.offsetY;\n      this._resetBaseColor = false;\n      this.draw();\n      const {\n        r,\n        g,\n        b\n      } = getColorAtPosition(this.ctx, e.offsetX, e.offsetY);\n      this.emitChange(new Color(r, g, b));\n    }\n  }\n  /** @nocollapse */NgxMatColorCanvasComponent.ɵfac = function NgxMatColorCanvasComponent_Factory(t) {\n    return new (t || NgxMatColorCanvasComponent)(i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n  NgxMatColorCanvasComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NgxMatColorCanvasComponent,\n    selectors: [[\"ngx-mat-color-canvas\"]],\n    hostAttrs: [1, \"ngx-mat-color-canvas\"],\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature],\n    decls: 30,\n    vars: 3,\n    consts: [[3, \"formGroup\"], [1, \"color-canvas-row\"], [1, \"zone-canvas\"], [\"id\", \"color-block\", \"width\", \"200\", \"height\", \"200\", 1, \"zone-block\", 3, \"mousedown\", \"mouseup\"], [3, \"colorChanged\"], [1, \"zone-inputs\"], [\"matInput\", \"\", \"formControlName\", \"r\", \"ngxMatNumericColorInput\", \"\", \"autocomplete\", \"off\"], [\"matInput\", \"\", \"formControlName\", \"g\", \"ngxMatNumericColorInput\", \"\", \"autocomplete\", \"off\"], [\"matInput\", \"\", \"formControlName\", \"b\", \"ngxMatNumericColorInput\", \"\", \"autocomplete\", \"off\"], [\"mat-mini-fab\", \"\", 1, \"preview\"], [\"matPrefix\", \"\", 1, \"symbol\"], [\"matInput\", \"\", \"formControlName\", \"hex\", \"autocomplete\", \"off\"], [\"matInput\", \"\", \"formControlName\", \"a\", \"type\", \"number\", \"min\", \"0\", \"max\", \"1\", \"step\", \"0.1\", \"autocomplete\", \"off\"]],\n    template: function NgxMatColorCanvasComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"form\", 0)(1, \"div\", 1)(2, \"div\", 2)(3, \"canvas\", 3);\n        i0.ɵɵlistener(\"mousedown\", function NgxMatColorCanvasComponent_Template_canvas_mousedown_3_listener($event) {\n          return ctx.onMousedown($event);\n        })(\"mouseup\", function NgxMatColorCanvasComponent_Template_canvas_mouseup_3_listener($event) {\n          return ctx.onMouseup($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(4, \"ngx-mat-color-slider\", 4);\n        i0.ɵɵlistener(\"colorChanged\", function NgxMatColorCanvasComponent_Template_ngx_mat_color_slider_colorChanged_4_listener($event) {\n          return ctx.onSliderColorChanged($event);\n        });\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(5, \"div\", 5)(6, \"mat-form-field\")(7, \"mat-label\");\n        i0.ɵɵtext(8, \"R\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(9, \"input\", 6);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(10, \"mat-form-field\")(11, \"mat-label\");\n        i0.ɵɵtext(12, \"G\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(13, \"input\", 7);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(14, \"mat-form-field\")(15, \"mat-label\");\n        i0.ɵɵtext(16, \"B\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(17, \"input\", 8);\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵelementStart(18, \"div\", 1);\n        i0.ɵɵelement(19, \"button\", 9);\n        i0.ɵɵelementStart(20, \"mat-form-field\")(21, \"mat-label\");\n        i0.ɵɵtext(22, \"HEX6\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(23, \"mat-label\", 10);\n        i0.ɵɵtext(24, \"#\\xA0\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(25, \"input\", 11);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(26, \"mat-form-field\")(27, \"mat-label\");\n        i0.ɵɵtext(28, \"A\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(29, \"input\", 12);\n        i0.ɵɵelementEnd()()();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"formGroup\", ctx.formGroup);\n        i0.ɵɵadvance(19);\n        i0.ɵɵstyleProp(\"background-color\", (ctx.color == null ? null : ctx.color.rgba) || \"transparent\");\n      }\n    },\n    dependencies: [i1.MatLegacyFormField, i1.MatLegacyLabel, i1.MatLegacyPrefix, i2.MatLegacyInput, i3.MatLegacyButton, i4.ɵNgNoValidate, i4.DefaultValueAccessor, i4.NumberValueAccessor, i4.NgControlStatus, i4.NgControlStatusGroup, i4.MinValidator, i4.MaxValidator, i4.FormGroupDirective, i4.FormControlName, NgxMatColorSliderComponent, NumericColorInputDirective],\n    styles: [\".ngx-mat-color-canvas .color-canvas-row{display:flex}.ngx-mat-color-canvas .color-canvas-row:first-of-type{height:200px;margin-bottom:12px}.ngx-mat-color-canvas .color-canvas-row:first-of-type .card{height:180px}.ngx-mat-color-canvas .color-canvas-row canvas:hover{cursor:crosshair}.ngx-mat-color-canvas .color-canvas-row .zone{display:flex}.ngx-mat-color-canvas .color-canvas-row .zone-canvas{height:200px}.ngx-mat-color-canvas .color-canvas-row .zone-canvas .zone-block{border:1px solid rgba(0,0,0,.12)}.ngx-mat-color-canvas .color-canvas-row .zone-strip{flex-basis:auto;margin-left:10px}.ngx-mat-color-canvas .color-canvas-row .zone-inputs{display:flex;width:40px;height:200px;flex-direction:column;margin-left:16px;margin-top:12px}.ngx-mat-color-canvas .color-canvas-row:nth-of-type(2){display:flex}.ngx-mat-color-canvas .color-canvas-row:nth-of-type(2) .preview{min-width:40px;min-height:40px;height:40px;width:40px}.ngx-mat-color-canvas .color-canvas-row:nth-of-type(2) .mat-form-field{margin-left:16px}.ngx-mat-color-canvas .color-canvas-row:nth-of-type(2) .mat-form-field:first-of-type{width:170px}.ngx-mat-color-canvas .color-canvas-row:nth-of-type(2) .mat-form-field:first-of-type .symbol{font-weight:700;color:#0000008a}.ngx-mat-color-canvas .color-canvas-row:nth-of-type(2) .mat-form-field:last-of-type{width:40px}.ngx-mat-color-canvas .mat-form-field-label{font-weight:700}\\n\"],\n    encapsulation: 2\n  });\n  return NgxMatColorCanvasComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgxMatColorCollectionComponent = /*#__PURE__*/(() => {\n  class NgxMatColorCollectionComponent {\n    constructor() {\n      this.colorChanged = new EventEmitter();\n      this.colors1 = BASIC_COLORS.slice(0, 8);\n      this.colors2 = BASIC_COLORS.slice(8, 16);\n    }\n    set color(c) {\n      if (c) {\n        this.selectedColor = c.toHexString();\n      }\n    }\n    ngOnInit() {}\n    select(hex) {\n      this.selectedColor = hex;\n      const {\n        r,\n        g,\n        b,\n        a\n      } = stringInputToObject(hex);\n      this.colorChanged.emit(new Color(r, g, b, a));\n    }\n  }\n  /** @nocollapse */NgxMatColorCollectionComponent.ɵfac = function NgxMatColorCollectionComponent_Factory(t) {\n    return new (t || NgxMatColorCollectionComponent)();\n  };\n  /** @nocollapse */\n  NgxMatColorCollectionComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NgxMatColorCollectionComponent,\n    selectors: [[\"ngx-mat-color-collection\"]],\n    hostAttrs: [1, \"ngx-mat-color-collection\"],\n    inputs: {\n      color: \"color\"\n    },\n    outputs: {\n      colorChanged: \"colorChanged\"\n    },\n    decls: 4,\n    vars: 2,\n    consts: [[1, \"color-collection-row\"], [\"mat-mini-fab\", \"\", \"class\", \"btn-color\", 3, \"background-color\", \"ngClass\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"mat-mini-fab\", \"\", 1, \"btn-color\", 3, \"ngClass\", \"click\"]],\n    template: function NgxMatColorCollectionComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵtemplate(1, NgxMatColorCollectionComponent_button_1_Template, 1, 5, \"button\", 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(2, \"div\", 0);\n        i0.ɵɵtemplate(3, NgxMatColorCollectionComponent_button_3_Template, 1, 5, \"button\", 1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.colors1);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngForOf\", ctx.colors2);\n      }\n    },\n    dependencies: [i1$1.NgClass, i1$1.NgForOf, i3.MatLegacyButton],\n    styles: [\".ngx-mat-color-collection .btn-color{height:20px;width:20px;margin-right:11px;box-shadow:none;opacity:.3}.ngx-mat-color-collection .btn-color.active{box-shadow:0 3px 5px -1px #0003,0 6px 10px #00000024,0 1px 18px #0000001f;opacity:1}\\n\"],\n    encapsulation: 2\n  });\n  return NgxMatColorCollectionComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgxMatColorPaletteComponent = /*#__PURE__*/(() => {\n  class NgxMatColorPaletteComponent {\n    constructor() {\n      this.colorChanged = new EventEmitter();\n    }\n    ngOnInit() {}\n    handleColorChanged(color) {\n      this.colorChanged.emit(color);\n    }\n  }\n  /** @nocollapse */NgxMatColorPaletteComponent.ɵfac = function NgxMatColorPaletteComponent_Factory(t) {\n    return new (t || NgxMatColorPaletteComponent)();\n  };\n  /** @nocollapse */\n  NgxMatColorPaletteComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NgxMatColorPaletteComponent,\n    selectors: [[\"ngx-mat-color-palette\"]],\n    hostAttrs: [1, \"ngx-mat-color-palette\"],\n    inputs: {\n      color: \"color\"\n    },\n    outputs: {\n      colorChanged: \"colorChanged\"\n    },\n    decls: 2,\n    vars: 2,\n    consts: [[3, \"color\", \"colorChanged\"]],\n    template: function NgxMatColorPaletteComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"ngx-mat-color-canvas\", 0);\n        i0.ɵɵlistener(\"colorChanged\", function NgxMatColorPaletteComponent_Template_ngx_mat_color_canvas_colorChanged_0_listener($event) {\n          return ctx.handleColorChanged($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(1, \"ngx-mat-color-collection\", 0);\n        i0.ɵɵlistener(\"colorChanged\", function NgxMatColorPaletteComponent_Template_ngx_mat_color_collection_colorChanged_1_listener($event) {\n          return ctx.handleColorChanged($event);\n        });\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"color\", ctx.color);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"color\", ctx.color);\n      }\n    },\n    dependencies: [NgxMatColorCanvasComponent, NgxMatColorCollectionComponent],\n    styles: [\".ngx-mat-color-palette .actions{margin-top:10px;display:flex}.ngx-mat-color-palette .actions .left{display:flex;flex-direction:column;margin-right:15px}.ngx-mat-color-palette .actions .left .preview{flex:2 1 auto;margin-bottom:10px}.ngx-mat-color-palette .actions .right{display:flex;width:40px;flex-direction:column}\\n\"],\n    encapsulation: 2\n  });\n  return NgxMatColorPaletteComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ColorAdapter = /*#__PURE__*/(() => {\n  class ColorAdapter {\n    constructor() {}\n    sameColor(a, b) {\n      if (a == null && b == null) return true;\n      if (a != null && b != null) return a.rgba === b.rgba;\n      return false;\n    }\n    format(c, format) {\n      return c.toString(format);\n    }\n    parse(value) {\n      const obj = stringInputToObject(value);\n      if (obj) {\n        return new Color(obj.r, obj.g, obj.b, obj.a);\n      }\n      return null;\n    }\n  }\n  /** @nocollapse */ColorAdapter.ɵfac = function ColorAdapter_Factory(t) {\n    return new (t || ColorAdapter)();\n  };\n  /** @nocollapse */\n  ColorAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ColorAdapter,\n    factory: ColorAdapter.ɵfac\n  });\n  return ColorAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NGX_MAT_COLOR_FORMATS = {\n  display: {\n    colorInput: 'hex'\n  }\n};\nconst MAT_COLOR_FORMATS = new InjectionToken('mat-color-formats');\n\n/** Injection token that determines the scroll handling while the calendar is open. */\nconst NGX_MAT_COLOR_PICKER_SCROLL_STRATEGY = new InjectionToken('ngx-mat-colorpicker-scroll-strategy');\nfunction NGX_MAT_COLOR_PICKER_SCROLL_STRATEGY_FACTORY(overlay) {\n  return () => overlay.scrollStrategies.reposition();\n}\nconst NGX_MAT_COLOR_PICKER_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n  provide: NGX_MAT_COLOR_PICKER_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: NGX_MAT_COLOR_PICKER_SCROLL_STRATEGY_FACTORY\n};\nconst _MatColorpickerContentBase = mixinColor(class {\n  constructor(_elementRef) {\n    this._elementRef = _elementRef;\n  }\n});\nlet NgxMatColorPickerContentComponent = /*#__PURE__*/(() => {\n  class NgxMatColorPickerContentComponent extends _MatColorpickerContentBase {\n    constructor(elementRef) {\n      super(elementRef);\n    }\n  }\n  /** @nocollapse */NgxMatColorPickerContentComponent.ɵfac = function NgxMatColorPickerContentComponent_Factory(t) {\n    return new (t || NgxMatColorPickerContentComponent)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  /** @nocollapse */\n  NgxMatColorPickerContentComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NgxMatColorPickerContentComponent,\n    selectors: [[\"ngx-mat-color-picker-content\"]],\n    viewQuery: function NgxMatColorPickerContentComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(NgxMatColorPaletteComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._palette = _t.first);\n      }\n    },\n    hostAttrs: [1, \"ngx-mat-colorpicker-content\"],\n    hostVars: 3,\n    hostBindings: function NgxMatColorPickerContentComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵsyntheticHostProperty(\"@transformPanel\", \"enter\");\n        i0.ɵɵclassProp(\"ngx-mat-colorpicker-content-touch\", ctx.picker.touchUi);\n      }\n    },\n    inputs: {\n      color: \"color\"\n    },\n    exportAs: [\"ngxMatColorPickerContent\"],\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"color\", \"colorChanged\"]],\n    template: function NgxMatColorPickerContentComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"ngx-mat-color-palette\", 0);\n        i0.ɵɵlistener(\"colorChanged\", function NgxMatColorPickerContentComponent_Template_ngx_mat_color_palette_colorChanged_0_listener($event) {\n          return ctx.picker.select($event);\n        });\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"color\", ctx.picker._selected);\n      }\n    },\n    dependencies: [NgxMatColorPaletteComponent],\n    styles: [\".ngx-mat-colorpicker-content{display:block;border-radius:4px;box-shadow:0 2px 4px -1px #0003,0 4px 5px #00000024,0 1px 10px #0000001f;background-color:#fff;color:#000000de;padding:16px}.ngx-mat-colorpicker-content .ngx-mat-color-palette{width:296px;height:354px}.ngx-mat-colorpicker-content-touch{display:block;max-height:80vh;overflow:auto}.ngx-mat-colorpicker-content-touch .ngx-mat-color-palette{min-width:250px;min-height:312px;max-width:750px;max-height:788px}@media all and (orientation: landscape){.mat-colorpicker-content-touch .ngx-mat-color-palette{width:64vh;height:80vh}}@media all and (orientation: portrait){.mat-colorpicker-content-touch .ngx-mat-color-palette{width:80vw;height:100vw}}\\n\"],\n    encapsulation: 2,\n    data: {\n      animation: [matDatepickerAnimations.transformPanel, matDatepickerAnimations.fadeInCalendar]\n    },\n    changeDetection: 0\n  });\n  return NgxMatColorPickerContentComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgxMatColorPickerComponent = /*#__PURE__*/(() => {\n  class NgxMatColorPickerComponent {\n    constructor(_dialog, _overlay, _zone, _adapter, _dir, scrollStrategy, _document, _viewContainerRef) {\n      this._dialog = _dialog;\n      this._overlay = _overlay;\n      this._zone = _zone;\n      this._adapter = _adapter;\n      this._dir = _dir;\n      this._document = _document;\n      this._viewContainerRef = _viewContainerRef;\n      /** Emits when the datepicker has been opened. */\n      this.openedStream = new EventEmitter();\n      /** Emits when the datepicker has been closed. */\n      this.closedStream = new EventEmitter();\n      this._touchUi = false;\n      this._opened = false;\n      this._defaultColor = 'primary';\n      this._validSelected = null;\n      /** Emits when the datepicker is disabled. */\n      this._disabledChange = new Subject();\n      /** The element that was focused before the datepicker was opened. */\n      this._focusedElementBeforeOpen = null;\n      /** Subscription to value changes in the associated input element. */\n      this._inputSubscription = Subscription.EMPTY;\n      /** Emits new selected date when selected date changes. */\n      this._selectedChanged = new Subject();\n      this._scrollStrategy = scrollStrategy;\n    }\n    get disabled() {\n      return this._disabled === undefined && this._pickerInput ? this._pickerInput.disabled : !!this._disabled;\n    }\n    set disabled(value) {\n      const newValue = coerceBooleanProperty(value);\n      if (newValue !== this._disabled) {\n        this._disabled = newValue;\n        this._disabledChange.next(newValue);\n      }\n    }\n    get touchUi() {\n      return this._touchUi;\n    }\n    set touchUi(value) {\n      this._touchUi = coerceBooleanProperty(value);\n    }\n    /** Whether the calendar is open. */\n    get opened() {\n      return this._opened;\n    }\n    set opened(value) {\n      value ? this.open() : this.close();\n    }\n    /** Default Color palette to use on the datepicker's calendar. */\n    get defaultColor() {\n      return this._defaultColor;\n    }\n    set defaultColor(value) {\n      this._defaultColor = value;\n    }\n    /** Color palette to use on the datepicker's calendar. */\n    get color() {\n      return this._color || (this._pickerInput ? this._pickerInput.getThemePalette() : undefined);\n    }\n    set color(value) {\n      this._color = value;\n    }\n    /** The currently selected date. */\n    get _selected() {\n      return this._validSelected;\n    }\n    set _selected(value) {\n      this._validSelected = value;\n    }\n    ngOnInit() {}\n    ngOnDestroy() {\n      this.close();\n      this._inputSubscription.unsubscribe();\n      this._disabledChange.complete();\n      if (this._popupRef) {\n        this._popupRef.dispose();\n        this._popupComponentRef = null;\n      }\n    }\n    /** Selects the given date */\n    select(nextVal) {\n      let oldValue = this._selected;\n      this._selected = nextVal;\n      if (!this._adapter.sameColor(oldValue, this._selected)) {\n        this._selectedChanged.next(nextVal);\n      }\n    }\n    /**\r\n    * Register an input with this datepicker.\r\n    * @param input The datepicker input to register with this datepicker.\r\n    */\n    registerInput(input) {\n      if (this._pickerInput) {\n        throw Error('A ColorPicker can only be associated with a single input.');\n      }\n      this._pickerInput = input;\n      this._inputSubscription = this._pickerInput._valueChange.subscribe(value => this._selected = value);\n    }\n    open() {\n      if (this._opened || this.disabled) {\n        return;\n      }\n      if (!this._pickerInput) {\n        throw Error('Attempted to open an ColorPicker with no associated input.');\n      }\n      if (this._document) {\n        this._focusedElementBeforeOpen = this._document.activeElement;\n      }\n      this.touchUi ? this._openAsDialog() : this._openAsPopup();\n      this._opened = true;\n      this.openedStream.emit();\n    }\n    /** Open the calendar as a dialog. */\n    _openAsDialog() {\n      if (this._dialogRef) {\n        this._dialogRef.close();\n      }\n      this._dialogRef = this._dialog.open(NgxMatColorPickerContentComponent, {\n        direction: this._dir ? this._dir.value : 'ltr',\n        viewContainerRef: this._viewContainerRef,\n        panelClass: 'ngx-mat-colorpicker-dialog'\n      });\n      this._dialogRef.afterClosed().subscribe(() => this.close());\n      this._dialogRef.componentInstance.picker = this;\n      this._setColor();\n    }\n    /** Open the calendar as a popup. */\n    _openAsPopup() {\n      if (!this._portal) {\n        this._portal = new ComponentPortal(NgxMatColorPickerContentComponent, this._viewContainerRef);\n      }\n      if (!this._popupRef) {\n        this._createPopup();\n      }\n      if (!this._popupRef.hasAttached()) {\n        this._popupComponentRef = this._popupRef.attach(this._portal);\n        this._popupComponentRef.instance.picker = this;\n        this._setColor();\n        // Update the position once the calendar has rendered.\n        this._zone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n          this._popupRef.updatePosition();\n        });\n      }\n    }\n    /** Create the popup. */\n    _createPopup() {\n      const overlayConfig = new OverlayConfig({\n        positionStrategy: this._createPopupPositionStrategy(),\n        hasBackdrop: true,\n        backdropClass: 'mat-overlay-transparent-backdrop',\n        direction: this._dir,\n        scrollStrategy: this._scrollStrategy(),\n        panelClass: 'mat-colorpicker-popup'\n      });\n      this._popupRef = this._overlay.create(overlayConfig);\n      this._popupRef.overlayElement.setAttribute('role', 'dialog');\n      merge(this._popupRef.backdropClick(), this._popupRef.detachments(), this._popupRef.keydownEvents().pipe(filter(event => {\n        // Closing on alt + up is only valid when there's an input associated with the datepicker.\n        return event.keyCode === ESCAPE || this._pickerInput && event.altKey && event.keyCode === UP_ARROW;\n      }))).subscribe(event => {\n        if (event) {\n          event.preventDefault();\n        }\n        this.close();\n      });\n    }\n    close() {\n      if (!this._opened) {\n        return;\n      }\n      if (this._popupRef && this._popupRef.hasAttached()) {\n        this._popupRef.detach();\n      }\n      if (this._dialogRef) {\n        this._dialogRef.close();\n        this._dialogRef = null;\n      }\n      if (this._portal && this._portal.isAttached) {\n        this._portal.detach();\n      }\n      const completeClose = () => {\n        // The `_opened` could've been reset already if\n        // we got two events in quick succession.\n        if (this._opened) {\n          this._opened = false;\n          this.closedStream.emit();\n          this._focusedElementBeforeOpen = null;\n        }\n      };\n      if (this._focusedElementBeforeOpen && typeof this._focusedElementBeforeOpen.focus === 'function') {\n        // Because IE moves focus asynchronously, we can't count on it being restored before we've\n        // marked the datepicker as closed. If the event fires out of sequence and the element that\n        // we're refocusing opens the datepicker on focus, the user could be stuck with not being\n        // able to close the calendar at all. We work around it by making the logic, that marks\n        // the datepicker as closed, async as well.\n        this._focusedElementBeforeOpen.focus();\n        setTimeout(completeClose);\n      } else {\n        completeClose();\n      }\n    }\n    /** Passes the current theme color along to the calendar overlay. */\n    _setColor() {\n      const color = this.color;\n      if (this._popupComponentRef) {\n        this._popupComponentRef.instance.color = color;\n      }\n      if (this._dialogRef) {\n        this._dialogRef.componentInstance.color = color;\n      }\n    }\n    /** Create the popup PositionStrategy. */\n    _createPopupPositionStrategy() {\n      return this._overlay.position().flexibleConnectedTo(this._pickerInput.getConnectedOverlayOrigin()).withTransformOriginOn('.ngx-mat-colorpicker-content').withFlexibleDimensions(false).withViewportMargin(8).withLockedPosition().withPositions([{\n        originX: 'start',\n        originY: 'bottom',\n        overlayX: 'start',\n        overlayY: 'top'\n      }, {\n        originX: 'start',\n        originY: 'top',\n        overlayX: 'start',\n        overlayY: 'bottom'\n      }, {\n        originX: 'end',\n        originY: 'bottom',\n        overlayX: 'end',\n        overlayY: 'top'\n      }, {\n        originX: 'end',\n        originY: 'top',\n        overlayX: 'end',\n        overlayY: 'bottom'\n      }]);\n    }\n  }\n  /** @nocollapse */NgxMatColorPickerComponent.ɵfac = function NgxMatColorPickerComponent_Factory(t) {\n    return new (t || NgxMatColorPickerComponent)(i0.ɵɵdirectiveInject(i2$1.MatLegacyDialog), i0.ɵɵdirectiveInject(i3$1.Overlay), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(ColorAdapter), i0.ɵɵdirectiveInject(i5.Directionality, 8), i0.ɵɵdirectiveInject(NGX_MAT_COLOR_PICKER_SCROLL_STRATEGY), i0.ɵɵdirectiveInject(DOCUMENT, 8), i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n  /** @nocollapse */\n  NgxMatColorPickerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NgxMatColorPickerComponent,\n    selectors: [[\"ngx-mat-color-picker\"]],\n    inputs: {\n      disabled: \"disabled\",\n      touchUi: \"touchUi\",\n      opened: \"opened\",\n      defaultColor: \"defaultColor\",\n      color: \"color\"\n    },\n    outputs: {\n      openedStream: \"opened\",\n      closedStream: \"closed\"\n    },\n    exportAs: [\"ngxMatColorPicker\"],\n    decls: 0,\n    vars: 0,\n    template: function NgxMatColorPickerComponent_Template(rf, ctx) {},\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return NgxMatColorPickerComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass NgxMatColorPickerInputEvent {\n  constructor( /** Reference to the colorpicker input component that emitted the event. */\n  target, /** Reference to the native input element associated with the colorpicker input. */\n  targetElement) {\n    this.target = target;\n    this.targetElement = targetElement;\n    this.value = this.target.value;\n  }\n}\nconst MAT_COLORPICKER_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => NgxMatColorPickerInput),\n  multi: true\n};\nconst MAT_COLORPICKER_VALIDATORS = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => NgxMatColorPickerInput),\n  multi: true\n};\nlet NgxMatColorPickerInput = /*#__PURE__*/(() => {\n  class NgxMatColorPickerInput {\n    constructor(_elementRef, _formField, _colorFormats, _adapter) {\n      this._elementRef = _elementRef;\n      this._formField = _formField;\n      this._colorFormats = _colorFormats;\n      this._adapter = _adapter;\n      /** Emits when a `change` event is fired on this `<input>`. */\n      this.colorChange = new EventEmitter();\n      /** Emits when an `input` event is fired on this `<input>`. */\n      this.colorInput = new EventEmitter();\n      /** Emits when the disabled state has changed */\n      this._disabledChange = new EventEmitter();\n      /** Emits when the value changes (either due to user input or programmatic change). */\n      this._valueChange = new EventEmitter();\n      this._onTouched = () => {};\n      this._cvaOnChange = () => {};\n      this._validatorOnChange = () => {};\n      this._pickerSubscription = Subscription.EMPTY;\n      /** The combined form control validator for this input. */\n      this._validator = Validators.compose([]);\n      /** Whether the last value set on the input was valid. */\n      this._lastValueValid = false;\n      if (!this._colorFormats) {\n        throw createMissingDateImplError('MAT_COLOR_FORMATS');\n      }\n    }\n    set ngxMatColorPicker(value) {\n      if (!value) {\n        return;\n      }\n      this._picker = value;\n      this._picker.registerInput(this);\n      this._pickerSubscription.unsubscribe();\n      this._pickerSubscription = this._picker._selectedChanged.subscribe(selected => {\n        this.value = selected;\n        this._cvaOnChange(selected);\n        this._onTouched();\n        this.colorInput.emit(new NgxMatColorPickerInputEvent(this, this._elementRef.nativeElement));\n        this.colorChange.emit(new NgxMatColorPickerInputEvent(this, this._elementRef.nativeElement));\n      });\n    }\n    /** Whether the colorpicker-input is disabled. */\n    get disabled() {\n      return !!this._disabled;\n    }\n    set disabled(value) {\n      const newValue = coerceBooleanProperty(value);\n      const element = this._elementRef.nativeElement;\n      if (this._disabled !== newValue) {\n        this._disabled = newValue;\n        this._disabledChange.emit(newValue);\n      }\n      // We need to null check the `blur` method, because it's undefined during SSR.\n      if (newValue && element.blur) {\n        // Normally, native input elements automatically blur if they turn disabled. This behavior\n        // is problematic, because it would mean that it triggers another change detection cycle,\n        // which then causes a changed after checked error if the input element was focused before.\n        element.blur();\n      }\n    }\n    /** The value of the input. */\n    get value() {\n      return this._value;\n    }\n    set value(value) {\n      const oldValue = this.value;\n      this._value = value;\n      this._formatValue(value);\n      if (!this._adapter.sameColor(oldValue, value)) {\n        this._valueChange.emit(value);\n      }\n    }\n    /** Returns the palette used by the input's form field, if any. */\n    getThemePalette() {\n      return this._formField ? this._formField.color : undefined;\n    }\n    registerOnValidatorChange(fn) {\n      this._validatorOnChange = fn;\n    }\n    validate(c) {\n      return this._validator ? this._validator(c) : null;\n    }\n    /**\r\n     * @deprecated\r\n     * @breaking-change 8.0.0 Use `getConnectedOverlayOrigin` instead\r\n     */\n    getPopupConnectionElementRef() {\n      return this.getConnectedOverlayOrigin();\n    }\n    /**\r\n    * Gets the element that the colorpicker popup should be connected to.\r\n    * @return The element to connect the popup to.\r\n    */\n    getConnectedOverlayOrigin() {\n      return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;\n    }\n    ngOnInit() {}\n    ngOnDestroy() {\n      this._pickerSubscription.unsubscribe();\n      this._valueChange.complete();\n      this._disabledChange.complete();\n    }\n    // Implemented as part of ControlValueAccessor.\n    writeValue(value) {\n      this.value = value;\n    }\n    // Implemented as part of ControlValueAccessor.\n    registerOnChange(fn) {\n      this._cvaOnChange = fn;\n    }\n    // Implemented as part of ControlValueAccessor.\n    registerOnTouched(fn) {\n      this._onTouched = fn;\n    }\n    // Implemented as part of ControlValueAccessor.\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n    _onChange() {\n      this.colorChange.emit(new NgxMatColorPickerInputEvent(this, this._elementRef.nativeElement));\n    }\n    _onKeydown(event) {\n      const isAltDownArrow = event.altKey && event.keyCode === DOWN_ARROW;\n      if (this._picker && isAltDownArrow && !this._elementRef.nativeElement.readOnly) {\n        this._picker.open();\n        event.preventDefault();\n      }\n    }\n    /** Handles blur events on the input. */\n    _onBlur() {\n      // Reformat the input only if we have a valid value.\n      if (this.value) {\n        this._formatValue(this.value);\n      }\n      this._onTouched();\n    }\n    /** Formats a value and sets it on the input element. */\n    _formatValue(value) {\n      this._elementRef.nativeElement.value = value ? this._adapter.format(value, this._colorFormats.display.colorInput) : '';\n    }\n    _onInput(value) {\n      const lastValueWasValid = this._lastValueValid;\n      const nextValue = this._adapter.parse(value);\n      if (!this._adapter.sameColor(nextValue, this._value)) {\n        this._value = nextValue;\n        this._cvaOnChange(nextValue);\n        this._valueChange.emit(nextValue);\n        this.colorInput.emit(new NgxMatColorPickerInputEvent(this, this._elementRef.nativeElement));\n      } else if (lastValueWasValid !== this._lastValueValid) {\n        this._validatorOnChange();\n      }\n    }\n  }\n  /** @nocollapse */NgxMatColorPickerInput.ɵfac = function NgxMatColorPickerInput_Factory(t) {\n    return new (t || NgxMatColorPickerInput)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.MatLegacyFormField, 8), i0.ɵɵdirectiveInject(MAT_COLOR_FORMATS, 8), i0.ɵɵdirectiveInject(ColorAdapter));\n  };\n  /** @nocollapse */\n  NgxMatColorPickerInput.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgxMatColorPickerInput,\n    selectors: [[\"input\", \"ngxMatColorPicker\", \"\"]],\n    hostVars: 3,\n    hostBindings: function NgxMatColorPickerInput_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"input\", function NgxMatColorPickerInput_input_HostBindingHandler($event) {\n          return ctx._onInput($event.target.value);\n        })(\"change\", function NgxMatColorPickerInput_change_HostBindingHandler() {\n          return ctx._onChange();\n        })(\"blur\", function NgxMatColorPickerInput_blur_HostBindingHandler() {\n          return ctx._onBlur();\n        })(\"keydown\", function NgxMatColorPickerInput_keydown_HostBindingHandler($event) {\n          return ctx._onKeydown($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵhostProperty(\"disabled\", ctx.disabled);\n        i0.ɵɵattribute(\"aria-haspopup\", ctx._picker ? \"dialog\" : null)(\"aria-owns\", (ctx._picker == null ? null : ctx._picker.opened) && ctx._picker.id || null);\n      }\n    },\n    inputs: {\n      ngxMatColorPicker: \"ngxMatColorPicker\",\n      disabled: \"disabled\",\n      value: \"value\"\n    },\n    outputs: {\n      colorChange: \"colorChange\",\n      colorInput: \"colorInput\"\n    },\n    exportAs: [\"ngxMatColorPickerInput\"],\n    features: [i0.ɵɵProvidersFeature([MAT_COLORPICKER_VALUE_ACCESSOR, MAT_COLORPICKER_VALIDATORS, {\n      provide: MAT_LEGACY_INPUT_VALUE_ACCESSOR,\n      useExisting: NgxMatColorPickerInput\n    }])]\n  });\n  return NgxMatColorPickerInput;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgxMatColorToggleComponent = /*#__PURE__*/(() => {\n  class NgxMatColorToggleComponent {\n    constructor(_cd) {\n      this._cd = _cd;\n      this._stateChanges = Subscription.EMPTY;\n    }\n    get disabled() {\n      if (this._disabled == null && this.picker) {\n        return this.picker.disabled;\n      }\n    }\n    set disabled(value) {\n      this._disabled = value;\n    }\n    ngOnInit() {}\n    ngOnChanges(changes) {\n      if (changes['picker']) {\n        this._watchStateChanges();\n      }\n    }\n    ngOnDestroy() {\n      this._stateChanges.unsubscribe();\n    }\n    ngAfterContentInit() {\n      this._watchStateChanges();\n    }\n    open(event) {\n      if (this.picker && !this.disabled) {\n        this.picker.open();\n        event.stopPropagation();\n      }\n    }\n    _watchStateChanges() {\n      const disabled$ = this.picker ? this.picker._disabledChange : of();\n      const inputDisabled$ = this.picker && this.picker._pickerInput ? this.picker._pickerInput._disabledChange : of();\n      const pickerToggled$ = this.picker ? merge(this.picker.openedStream, this.picker.closedStream) : of();\n      this._stateChanges.unsubscribe();\n      this._stateChanges = merge(disabled$, inputDisabled$, pickerToggled$).subscribe(() => this._cd.markForCheck());\n    }\n  }\n  /** @nocollapse */NgxMatColorToggleComponent.ɵfac = function NgxMatColorToggleComponent_Factory(t) {\n    return new (t || NgxMatColorToggleComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n  /** @nocollapse */\n  NgxMatColorToggleComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NgxMatColorToggleComponent,\n    selectors: [[\"ngx-mat-color-toggle\"]],\n    viewQuery: function NgxMatColorToggleComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c1, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._button = _t.first);\n      }\n    },\n    hostAttrs: [1, \"ngx-mat-color-toggle\"],\n    hostVars: 7,\n    hostBindings: function NgxMatColorToggleComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focus\", function NgxMatColorToggleComponent_focus_HostBindingHandler() {\n          return ctx._button.focus();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", -1);\n        i0.ɵɵclassProp(\"ngx-mat-color-toggle-active\", ctx.picker && ctx.picker.opened)(\"mat-accent\", ctx.picker && ctx.picker.color === \"accent\")(\"mat-warn\", ctx.picker && ctx.picker.color === \"warn\");\n      }\n    },\n    inputs: {\n      picker: [\"for\", \"picker\"],\n      tabIndex: \"tabIndex\",\n      disabled: \"disabled\"\n    },\n    exportAs: [\"ngxMatColorPickerToggle\"],\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 4,\n    vars: 5,\n    consts: [[\"mat-icon-button\", \"\", \"type\", \"button\", 3, \"disabled\", \"click\"], [\"button\", \"\"]],\n    template: function NgxMatColorToggleComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"button\", 0, 1);\n        i0.ɵɵlistener(\"click\", function NgxMatColorToggleComponent_Template_button_click_0_listener($event) {\n          return ctx.open($event);\n        });\n        i0.ɵɵelementStart(2, \"mat-icon\");\n        i0.ɵɵtext(3, \"palette\");\n        i0.ɵɵelementEnd()();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"disabled\", ctx.disabled);\n        i0.ɵɵattribute(\"aria-haspopup\", ctx.picker ? \"dialog\" : null)(\"tabindex\", ctx.disabled ? -1 : ctx.tabIndex);\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"color\", ctx.picker == null ? null : ctx.picker._selected == null ? null : ctx.picker._selected.rgba);\n      }\n    },\n    dependencies: [i3.MatLegacyButton, i2$2.MatIcon],\n    styles: [\".mat-form-field-appearance-legacy .mat-form-field-prefix .ngx-mat-color-toggle-default-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .ngx-mat-color-toggle-default-icon{width:1em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .ngx-mat-color-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .ngx-mat-color-toggle-default-icon{display:block;width:1.5em;height:1.5em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .ngx-mat-color-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .ngx-mat-color-toggle-default-icon{margin:auto}\\n\"],\n    encapsulation: 2\n  });\n  return NgxMatColorToggleComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgxMatColorPickerModule = /*#__PURE__*/(() => {\n  class NgxMatColorPickerModule {}\n  /** @nocollapse */NgxMatColorPickerModule.ɵfac = function NgxMatColorPickerModule_Factory(t) {\n    return new (t || NgxMatColorPickerModule)();\n  };\n  /** @nocollapse */\n  NgxMatColorPickerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxMatColorPickerModule\n  });\n  /** @nocollapse */\n  NgxMatColorPickerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [ColorAdapter, NGX_MAT_COLOR_PICKER_SCROLL_STRATEGY_FACTORY_PROVIDER],\n    imports: [CommonModule, MatLegacyInputModule, MatLegacyButtonModule, MatLegacyCardModule, MatLegacyRadioModule, FormsModule, ReactiveFormsModule, MatLegacyDialogModule, PortalModule, MatIconModule]\n  });\n  return NgxMatColorPickerModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\r\n * Public API Surface of color-picker\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { BASIC_COLORS, Color, ColorAdapter, MAT_COLORPICKER_VALIDATORS, MAT_COLORPICKER_VALUE_ACCESSOR, MAT_COLOR_FORMATS, MAX_RGB, MIN_RGB, NGX_MAT_COLOR_FORMATS, NGX_MAT_COLOR_PICKER_SCROLL_STRATEGY, NGX_MAT_COLOR_PICKER_SCROLL_STRATEGY_FACTORY, NGX_MAT_COLOR_PICKER_SCROLL_STRATEGY_FACTORY_PROVIDER, NUMERIC_REGEX, NgxMatColorCanvasComponent, NgxMatColorCollectionComponent, NgxMatColorPaletteComponent, NgxMatColorPickerComponent, NgxMatColorPickerContentComponent, NgxMatColorPickerInput, NgxMatColorPickerInputEvent, NgxMatColorPickerModule, NgxMatColorSliderComponent, NgxMatColorToggleComponent, NumericColorInputDirective, convertDecimalToHex, createMissingDateImplError, getColorAtPosition, matchers, pad2, rgbToHex, rgbaToHex, stringInputToObject };\n//# sourceMappingURL=angular-material-components-color-picker.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}